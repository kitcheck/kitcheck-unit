module Unit
  class Parser < StringScanner
    def parse
      ast = generate_ast
      interpret_ast(ast)
    end

    private

    #Interprets the code generated by the generate_ast method to create objects such as Mass, Volume, or Concentration
    def interpret_ast(ast)
      # Turns nodes into Mass or Volume objects if they match
      units = modify_nodes(ast)
      #Is there a slash?
      slash_index = units.index{|u| u.to_s == "/"}
      if slash_index.nil? #No slash, reduce the array into a single Mass or Volume object
        units.reduce(:+)
      else #This is a concentration, or at least an attempt
        if units.size > 1 #Valid concentration
          numerator = units[0...slash_index].reduce(:+) #Find numerators and sum
          denom = units[slash_index+1..units.size].reduce(:+) #Find denominators and sum
          Concentration.new(numerator, denom)
        else #There is a slash but no denominator, cannot parse
          raise "Invalid string"
        end
      end
    end

    #Creates units from the strings matched in generate AST
    def modify_nodes(ast)
      ast.map do |node|
        #Grab the scalar value of the string
        scalar = scalar_regex.match(node)
        #Grab the uom of the string
        uom = uom_regex.match(node)
        if scalar.to_s == "" #If we don't match a unit for the uom we will assume it's 1
          scalar = 1
        end
        #Creates and returns the object for that uom
        if !(scalar == "") && !(uom == "") && node != "/"
          uom_string = uom.to_s.downcase
          determine_class(uom_string).new(scalar.to_s, uom_string)
        else
          node
        end
      end
    end

    #Generates an array of "nodes", each of which represents a parsable set of text
    def generate_ast
      ast = []
      #While we haven't reached the end of the string
      while !eos?
        if scan(/\/{1}/) #Match slash
          ast << '/'
        elsif scan(unit_regex) #Should match a set of unit strings
          ast << matched
        else
          getch #Throw this index away because we don't match on it
        end
      end
      #Return the array of matchable content
      ast
    end

    def unit_regex
      Regexp.new(scalar_regex.to_s + /[[:space:]]*/.to_s + uom_regex.to_s)
    end

    def scalar_regex
      #\d Match a digit
      #\.{0,1} Match 0 or 1 decimal points
      #\d+ If there is a decimal point, match any digit after the decimal
      /[\d]*[\.{1}[\d+]]*/
    end

    def uom_regex
      /[[:alpha:]]+/
    end

    def determine_class(uom)
      if Mass.scale_hash.keys.include? uom
        Mass
      elsif Volume.scale_hash.keys.include? uom
        Volume
      elsif Unit.scale_hash.keys.include? uom
        Unit
      else
        raise IncompatibleUnitsError.new("This unit is incompatible (#{uom})")
      end
    end
  end
end
